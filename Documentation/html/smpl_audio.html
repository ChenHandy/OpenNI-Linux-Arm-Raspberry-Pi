<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.4: NiAudioSample.cpp - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NiAudioSample.cpp - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>NiAudioSample.cpp</li>
</ul>
<p>This section describes an OpenNI sample program for using the Audio interface.</p>
<p>The documentation describes the sample program's code from the top of the program file(s) to bottom.</p>
<p>This documentation item describes only OpenNI code features. Third party features, e.g., GL code, may be ignored. However, place holders as section headings appear in place of complete functions or large code blocks that are not OpenNI specific or key to understanding the logic of the sample program. These place holders are section headings with minimal text to enable the reader to identify the original program structure when studying the documentation.</p>
<p>Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.</p>
<h1><a class="anchor" id="bkrec_macros"></a>
Macro Declarations</h1>
<pre class="fragment">At the top of the program is a macro utility declaration, which calls OpenNI methods. It is described below. However, for the sake of conciseness, the rest of this documentation skips calls to this macro.

The CHECK_RC() macro checks whether the most recent OpenNI operation was successful or returned an error result. On error, the @ref xn::xnGetStatusString "xnGetStatusString()" method converts the OpenNI error return code to the corresponding error string for printing, and the current function exits.
@code 
    #define CHECK_RC(rc, what) \
        if (rc != XN_STATUS_OK)                                     \
        {                                                           \
            printf("%s failed: %s\n", what, xnGetStatusString(rc)); \
            return rc;                                              \
        }
@endcode    
</pre><h1><a class="anchor" id="rec_syn_sample_xml_path"></a>
Declaration of File Path</h1>
<pre class="fragment">In the following definitions, SAMPLE_XML_PATH is for the path to an OpenNI XML script input file for building a production graph. The &lt;i&gt;production graph&lt;/i&gt; is a network of &lt;i&gt;production nodes&lt;/i&gt; and is the principal OpenNI object model. See @ref prod_graph for more about the production graph.
@code 
    #define SAMPLE_XML_PATH "../../../../Data/SamplesConfig.xml"
@endcode
</pre><h1><a class="anchor" id="aud_glb_dcl_blk_ref"></a>
"Declaration Block" section</h1>
<pre class="fragment">The reader may find it convenient to study the global declaration block before continuing to study the code statements. The global declaration block is documented later in this section, corresponding to its position in the program file &amp;ndash; see @ref aud_glb_dcl_blk.
</pre><h1><a class="anchor" id="aud_decl_mode"></a>
enum Mode</h1>
<pre class="fragment">The following declaration defines the  program mode, whether whether it is recording an OpenNI data generation session or whether  it is playing a recording.
@code 
    enum Mode
    {
        MODE_PLAY,
        MODE_RECORD,
    };
@endcode

This declaration is not OpenNI specific.
</pre><h1><a class="anchor" id="aud_printusage"></a>
printUsage() method</h1>
<pre class="fragment">This function is not OpenNI specific.       
</pre><h1><a class="anchor" id="aud_play"></a>
play() method - Play Audio</h1>
<pre class="fragment">This routine gets an array of AudioGenerators, takes the first one, and constantly reads data from it and sends it to be played.

The following code block gets the first AudioGenerator node's wave output mode. It is received in an xn::XnWaveOutputMode, which comprises: bits per sample, channel, and sample rate. This information is then used for setting up the audio output buffers for collecting the generated play data and for setting up the hardware audio output channel.
@code 
    XnWaveOutputMode waveMode;
    nRetVal = aGens[0].GetWaveOutputMode(waveMode);
    CHECK_RC(nRetVal, "Failed getting wave output mode");
@endcode

The above completes the initialization. The following code is the main program loop.

The application calls an 'Update Data()' method, in this case the node's @ref xn::Generator::WaitAndUpdateData "WaitAndUpdateData", to make a new frame available for getting. The application can then get the data (for example, using a metadata GetData() method).
@code 
    nRetVal = aGens[0].WaitAndUpdateData();
@endcode

Assuming the above call succeeded, the application then gets the size of the audio data that was generated by the AudioGenerator node.
@code 
    XnUInt32 nBufferSize = aGens[0].GetDataSize();
@endcode

The next OpenNI statements copy the AudioGenerator node's data into a prepared buffer to be sent to the machine sound card. &lt;code&gt;xnOSMemCopy&lt;/code&gt; is OpenNI memory copy routine.
@code 
    xnOSMemCopy(pHeader-&gt;lpData, aGens[0].GetAudioBuffer(), nBufferSize);
    pHeader-&gt;dwBufferLength = nBufferSize;
@endcode
</pre><h1><a class="anchor" id="aud_record"></a>
record() method - Record Audio</h1>
<pre class="fragment">This method gets a list of audio generators, and records to a separate file the data generated by each generator .  
The following code block creates files named with the names of the AudioGenerator nodes.
@code 
    XN_FILE_HANDLE aFiles[nSupportedNodes];
    for (XnUInt32 i = 0; i &lt; nNodes; ++i)
    {
        XnChar strFileName[XN_FILE_MAX_PATH];
        sprintf(strFileName, "audio.%s.pcm", aGens[i].GetName());
        nRetVal = xnOSOpenFile(strFileName, XN_OS_FILE_WRITE, &amp;aFiles[i]);
        CHECK_RC(nRetVal, "Open file");
    }
@endcode        

The application then calls an @ref conc_updating_data "'Update Data'" method, in this case xn::Context.WaitAnyUpdateAll(), to update all generator nodes in the context to the latest available data, first waiting for any of the nodes to have new data available. The first call is used just to flush the node. 
@code 
    context.WaitAnyUpdateAll();
@endcode

The following loop checks which node has new data and writes it to a file. The IsDataNew() method returns whether a node's frame data was updated by the most recent call to the WaitAnyUpdateAll() method.
@code 
    XN_FILE_HANDLE aFiles[nSupportedNodes];
       ...
       ...
    for (XnUInt32 i = 0; i &lt; nNodes; ++i)
    {
        if (aGens[i].IsDataNew())
        {
            nRetVal = xnOSWriteFile(aFiles[i], aGens[i].GetAudioBuffer(), aGens[i].GetDataSize());
            CHECK_RC(nRetVal, "Write to file");
        }
    }
@endcode    
</pre><h1><a class="anchor" id="aud_mainprg"></a>
Main Program</h1>
<pre class="fragment">@subsection aud_glb_dcl_blk "Declaration Block" section     

    The declaration block at the top of the main program declares a @ref xn::Context object, an @ref xn::EnumerationErrors object, and an xn::ScriptNode object. The Context object is a workspace in which the application builds an OpenNI production graph. the @ref xn::EnumerationErrors object is for collecting errors from any of the OpenNI functions. Also declared is an OpenNI status flag for collecting return values from method calls. the @ref xn::ScriptNode object loads an XML script from a file or string, and then runs the XML script to build a production graph.      

    @code 
        XnStatus nRetVal = XN_STATUS_OK;
        Context context;
        EnumerationErrors errors;
          ...
        ScriptNode scriptNode;
    @endcode

@subsection aud_main_code Main Code Section     

    In the following, the InitFromXmlFile() method is a shorthand combination of two other initialization methods &amp;ndash; Init() and then RunXmlScriptFromFile() &amp;ndash; which initializes the context object and then creates a production graph from an XML file. 
    @code 
        nRetVal = context.InitFromXmlFile(SAMPLE_XML_PATH, scriptNode);         
    @endcode

    The following code block tests whether a production graph was created. If not, the reason is reported as a list of one or more errors in the &lt;code&gt;errors&lt;/code&gt; object.
    @code 
        if (nRetVal == XN_STATUS_NO_NODE_PRESENT)
        {
            XnChar strError[1024];
            errors.ToString(strError, 1024);
            printf("%s\n", strError);
            return (nRetVal);
        }
    @endcode

    The following code block searches for xn::AudioGenerator nodes in the production graph. The nodes are returned in the @ref xn::NodeInfoList object. This object is a list xn::NodeInfo objects, each containing information about a node found in the above  EnumerateExistingNodes() call. 

    @code 
        NodeInfoList list;
        nRetVal = context.EnumerateExistingNodes(list, XN_NODE_TYPE_AUDIO);
        CHECK_RC(nRetVal, "Enumerate audio nodes"); 
        AudioGenerator gens[nSupportedNodes];
        XnUInt32 nNodes = 0;
    @endcode

    The following declarations and statements get all the @ref xn::AudioGenerator nodes that were found by the EnumerateExistingNodes() call. The &lt;code&gt;gens&lt;/code&gt; array receives all the nodes, and they are counted by the &lt;code&gt;nNodes&lt;/code&gt; variable. (Currently, only a single AudioGenerator node is supported for playing at at once.)
    @code 
        AudioGenerator gens[nSupportedNodes];
        XnUInt32 nNodes = 0;
           ...
        for (NodeInfoList::Iterator it = list.Begin(); it != list.End(); ++it)
        {
            NodeInfo info = *it;
            nRetVal = info.GetInstance(gens[nNodes]);
            CHECK_RC(nRetVal, "Get audio node");
            nNodes++;
        }
    @endcode</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 17 2014 17:19:10 for OpenNI 1.5.4 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
