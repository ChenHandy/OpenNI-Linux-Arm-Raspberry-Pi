<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.4: Device.cpp file</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li><li class="navelem"><a class="el" href="smpl_niviewer.html">NiViewer - sample program</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Device.cpp file </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source files:</b> Click the following link to view the source code file:</p>
<ul>
<li>Device.cpp</li>
</ul>
<p>This file contains the code for declaring, initalizing, and creating the basic OpenNI objects and nodes, and provides the basic access routiese.</p>
<h1><a class="anchor" id="device_cpp_decls"></a>
Main File Declarations</h1>
<h1><a class="anchor" id="device_cpp_decls"></a>
Main File Declarations</h1>
<pre class="fragment">The declarations at the head of this file define the main OpenNI objects and other environment variables.

The following declarations define two of the main OpenNI objects required for building the OpenNI @ref prod_graph "production graph". The production graph is the main object in OpenNI.        
@code 
    Context g_Context;
    ScriptNode g_scriptNode;
@endcode

These two declarations are described separately in the following paragraphs.    

the @ref xn::ScriptNode object loads an XML script from a file or string, and then runs the XML script to build a production graph.             

The &lt;i&gt;@ref prod_graph "Production Graph"&lt;/i&gt; is a network of software objects - called production nodes - that can identify blobs as hands or human users. In this sample program the production graph identifies blobs as human users, and tracks them as they move. 

a @ref xn::Context object is a workspace in which the application builds an OpenNI production graph.    

The following declarations define some environment variables. They are not OpenNI related.
@code 
    DeviceStringProperty g_PrimaryStream;
    ...
@endcode

The following declarations define more main OpenNI objects.
@code 
    Device g_Device;
    DepthGenerator g_Depth;
    ImageGenerator g_Image;
    IRGenerator g_IR;
    AudioGenerator g_Audio;
    Player g_Player;
@endcode
Each of these declarations is described separately in the following paragraphs. 

A @ref xn::Device "Device" node represents a physical hardware device currently connected in the system and used for generating data. The Device node represents the hardware device by providing, for example, the device's name, serial number, and specific vendors. The Device node itself does not generate data.      

a @ref xn::DepthGenerator node generates a depth map. Each map pixel value represents a distance from the sensor.               
@code 
    DepthGenerator depthGen;
@endcode

A @ref xn::ImageGenerator "ImageGenerator" node generates color image maps of various formats, such as the RGB24 image format. Call its @ref xn::ImageGenerator::SetPixelFormat() "SetPixelFormat()" method to set the image format to be generated.        

A @ref xn::IRGenerator "IRGenerator" node is a map generator that outputs infra-red maps. 
The IR Generator node supports all MapGenerator functionality, as well as adding additional functionality.

A @ref xn::AudioGenerator "AudioGenerator" node generates audio data. 

A @ref xn::Player "Player" node plays a saved recording of an OpenNI data generation session.

The following declarations define OpenNI use metadata classes to create @ref conc_meta_data "frame objects". The metadata classes provide @ref glos_frame_object "frame objects" to the corresponding generator nodes to support fast data access. for example, the @ref xn::DepthMetaData "DepthMetaData" object provides a frame object for a @ref xn::DepthGenerator "DepthGenerator" node, and so on.       
@code 
    DepthMetaData g_DepthMD;
    ImageMetaData g_ImageMD;
    IRMetaData g_irMD;
    AudioMetaData g_AudioMD;
@endcode

This program file makes extensive use of &lt;code&gt;g_pPrimary&lt;/code&gt;. This is a pointer to a @ref xn::ProductionNode "ProductionNode" object to point to just one of the @ref xn::Generator "Generator nodes". This node is then termed the primary node in this sample program. &lt;code&gt;g_pPrimary&lt;/code&gt; selectas which output map to display on the graphic display.  &lt;code&gt;g_pPrimary&lt;/code&gt; is assigned its value in the &lt;code&gt;changePrimaryStream()&lt;/code&gt; function.

The ProductionNode class is a base class for all production nodes of the @ref prod_graph "Production Graph", including all @ref xn::Generator "Generator" nodes. Note that the &lt;code&gt;g_pPrimary pointer&lt;/code&gt; is never itself used to make an object or node, but just to point to a node created somewhere else.          
@code 
    ProductionNode* g_pPrimary = NULL;
@endcode
</pre><h1><a class="anchor" id="device_cpp_initConstants"></a>
- onErrorStateChanged() - Callback invoked when  the Error State Changed</h1>
<pre class="fragment">In the following code block (shown in part), &lt;code&gt;g_PrimaryStream&lt;/code&gt; is initialized with the enum IDs of all different types of production nodes, e.g., @ref xn::XN_NODE_TYPE_DEPTH means a DepthGenerator node.
@code 
    g_PrimaryStream.pValues[nIndex++] = "Any";
    g_PrimaryStream.pValues[nIndex++] = xnProductionNodeTypeToString(XN_NODE_TYPE_DEPTH);
    g_PrimaryStream.pValues[nIndex++] = xnProductionNodeTypeToString(XN_NODE_TYPE_IMAGE);
    g_PrimaryStream.pValues[nIndex++] = xnProductionNodeTypeToString(XN_NODE_TYPE_IR);
     ...
@endcode

In the following code block (shown in part), &lt;code&gt;g_Resolution&lt;/code&gt; is initialized with all possible image map resolutions.
@code 
    g_Resolution.pValues[nIndex++] = XN_RES_QVGA;
    g_Resolution.pValueToName[XN_RES_QVGA] = Resolution(XN_RES_QVGA).GetName();
    g_Resolution.pValues[nIndex++] = XN_RES_VGA;
    g_Resolution.pValueToName[XN_RES_VGA] = Resolution(XN_RES_VGA).GetName();           
@endcode
</pre><h1><a class="anchor" id="device_cpp_initConstants"></a>
- onErrorStateChanged() - Callback invoked when  the Error State Changed</h1>
<pre class="fragment">This function tests whether the error state is now xn::XN_STATUS_OK, i.e., no error, or is an error. On error, the error message is accessed according to the value of @ref xn::XnStatus "errorState". The high word represents the error group of the  error. The low word is the sequential error number within the group. 
</pre><h1><a class="anchor" id="device_cpp_openCommon"></a>
- openCommon() - Common Initialize Function</h1>
<pre class="fragment">This is a common initialize function called from a number of more specific functions that initialize the production graph.      
@code 
    void openCommon()
    {
        ...
    }           
@endcode            

This function uses @ref xn::Context::EnumerateExistingNodes to enumerate for all production nodes defined in the production graph, which returns in the &lt;code&gt;list&lt;/code&gt; return parameter a @ref xn::NodeInfoList containing all the context's existing created nodes. Each node is represented by a @ref xn::NodeInfo "NodeInfo" object in the list. 

The following for-loop iterates for all NodeInfo objects in the list. For each NodeInfo object found, this function calls @ref xn::NodeInfo::GetInstance() "GetInstance()" to return a reference to the actual production node instance represented by this NodeInfo object. The for-loop is shown below (in part): 
@code 
    for (NodeInfoList::Iterator it = list.Begin(); it != list.End(); ++it)
    {
        switch ((*it).GetDescription().Type)
        {
        case XN_NODE_TYPE_DEVICE:
            (*it).GetInstance(g_Device);
            break;
        case XN_NODE_TYPE_DEPTH:
            g_bIsDepthOn = true;
            (*it).GetInstance(g_Depth);
            break;
        ...
    }
@endcode

The above loop sets the generating state of all nodes to 'On', e.g., &lt;code&gt;g_bIsDepthOn = true&lt;/code&gt;.

The following statement registers an event handler, &lt;code&gt;onErrorStateChanged()&lt;/code&gt;, for all OpenNI errors that might occur. 
@code 
    g_Context.RegisterToErrorStateChange(onErrorStateChanged, NULL, hDummy);
@endcode

The following statements initialize the constants (see @ref device_cpp_initConstants above) and calls the @ref device_cpp_readFrame "readFrame()" method to read the first data frame. The readFrame() method reads the data frame from each and every one of all the generators in the production graph. 
@code 
    initConstants();
    readFrame();
@endcode
</pre><h1><a class="anchor" id="device_cpp_openDeviceFile"></a>
- openDeviceFile() - Builds a Production Graph from an OpenNI Recording File</h1>
<pre class="fragment">This function sets up a replay of a session of OpenNI data generation exactly as it was recorded on an ONI file.

The following call to the @ref xn::Context::Init() "Context::Init()" method builds the context's general software environment. This method initializes runtime variables and data structures, and examines all registered plug-ins to learn the purpose and specific capabilities of each. In particular, during initialization the context initialization examines all registered plug-ins to learn the purpose and specific capabilities of each.             
@code 
    XnStatus nRetVal = g_Context.Init();
@endcode

In the following, if &lt;code&gt;nRetVal&lt;/code&gt; is an error value, the @ref xn::XN_IS_STATUS_OK "XN_IS_STATUS_OK()" macro halts program execution, returning nRetVal as the error value.  
@code 
    XN_IS_STATUS_OK(nRetVal);
@endcode

The following call to @ref xn::Context::OpenFileRecording() "OpenFileRecording()" recreates a production graph from a recorded ONI file and then replays the data generation exactly as it was recorded. The &lt;code&gt;csFile &lt;/code&gt;parameter provides the name of the recorded file to be run. The &lt;code&gt;g_Player&lt;/code&gt; parameter returns a @ref xn::ProductionNode object through which playback can be controlled, e.g., seeking and setting playback. 
@code 
    nRetVal = g_Context.OpenFileRecording(csFile, g_Player);
@endcode

The &lt;code&gt;openCommon()&lt;/code&gt; method, called in the following statement, is descibed above in @ref device_cpp_openCommon.
</pre><h1><a class="anchor" id="device_cpp_openDeviceFromXml"></a>
- openDeviceFromXml() - Builds a Production Graph from an OpenNI XML Script File</h1>
<pre class="fragment">The following call to the @ref xn::Context::InitFromXmlFile() "Context.InitFromXmlFile()" method builds the context's general software environment (see &lt;code&gt;g_Context.Init()&lt;/code&gt; above) and then recreates a production graph from the specified OpenNI XML script file. This method is not for replaying a recording (compare with OpenFileRecording above).
@code 
    nRetVal = g_Context.InitFromXmlFile(csXmlFile, g_scriptNode, &amp;errors);
@endcode

In the following statement, if &lt;code&gt;nRetVal&lt;/code&gt; is an error value, the @ref xn::XN_IS_STATUS_OK "XN_IS_STATUS_OK()" macro halts program execution, returning nRetVal as the error value.    
@code 
    XN_IS_STATUS_OK(nRetVal);
@endcode            
</pre><h1><a class="anchor" id="device_cpp_openDeviceFromXmlWithChoice"></a>
- openDeviceFromXmlWithChoice() - Builds a Production Graph from an XML Script, Allowing User to Select a Device</h1>
<pre class="fragment">This function does the same as the previous function, i.e., it builds the Production Graph from an OpenNI XML Script File, but it allows the user to intervene and select a device.

the @ref xn::Context::EnumerateProductionTrees() method enumerates all available production nodes for a specific node type (e.g., the application wants to create a @ref xn::Device node) and returns a full list of matching production nodes.

This function then gets the device IDs of all the devices it finds in the production graph using xn::Device::GetIdentificationCap() "GetIdentificationCap()".

The function then interacts with the user using simple C functions to allow the user to select which device to use.
</pre><h1><a class="anchor" id="device_cpp_closeDevice"></a>
- closeDevice() - Releases all the Production Nodes</h1>
<pre class="fragment">This function releases all the production graph nodes.
</pre><h1><a class="anchor" id="device_cpp_readFrame"></a>
readFrame() function - Reads a Data frame from each Generator</h1>
<pre class="fragment">This function reads a data frame from each of the generators in the production graph.

If &lt;code&gt;g_pPrimary&lt;/code&gt; has been set to point to any particular node (i.e., not NULL; &lt;code&gt;g_pPrimary&lt;/code&gt; is initialized in the &lt;code&gt;changePrimaryStream()&lt;/code&gt; function) then this function calls @ref xn::Context::WaitOneUpdateAll() "WaitOneUpdateAll()" to wait only for that particular node to generate new data, and then this function refreshes the data available in all the nodes.

&lt;code&gt;g_pPrimary&lt;/code&gt; can be pointing to NULL. This is a valid user selection, available from the GUI menu. &lt;code&gt;g_pPrimary&lt;/code&gt; == NULL means that the user is not selcting any particular generator node. 

Then the function checks if all the node pointers (e.g., &lt;code&gt;g-depth&lt;/code&gt;) point to real nodes, and if so the function gets the node's @ref glos_frame_object "frame object", saving it in a metadata object. For example: the application saves a frame object from a  @ref xn::DepthGenerator "DepthGenerator" node as a ref xn::DepthMetaData object. 
@code 
    if (g_Depth.IsValid())
    {
        g_Depth.GetMetaData(g_DepthMD);
    }
@endcode
This frame object provides fast access to the saved generated data and its associated configuration.
</pre><h1><a class="anchor" id="device_cpp_changeRegistration"></a>
changeRegistration() - Changes the View Point Registration</h1>
<pre class="fragment">&lt;i&gt;Viewpoint registration&lt;/i&gt; is an OpenNI term for performing the mathematical conversion of one node's coordinate system to match the coordinate system of another node.

In this sample program, this specific function can toggle the viewpoint registration of the DepthGenerator node to that of the ImageGenerator node and back again - i.e., reset it - depending on the input parameter. This particular conversion is a consequence of the particular type of the supplied hardware sensor. 

The following test checks verifies that the DepthGenerator node is a valid node and that it supports the Alternative View Point capability.
@code 
    if (!g_Depth.IsValid() || !g_Depth.IsCapabilitySupported(XN_CAPABILITY_ALTERNATIVE_VIEW_POINT))
    {
        return;
    }               
@endcode

The following code block calls @ref xn::AlternativeViewPointCapability methods to toggle the viewpoint registration, as explained above.
@code 
    if (!nValue)
    {
        g_Depth.GetAlternativeViewPointCap().ResetViewPoint();
    }
    else if (g_Image.IsValid())
    {
        g_Depth.GetAlternativeViewPointCap().SetViewPoint(g_Image);
    }
@endcode
</pre><h1><a class="anchor" id="device_cpp_changePrimaryStream"></a>
changePrimaryStream() function - Change the Primary stream</h1>
<pre class="fragment">This function selects from which node the application will take generated data. It selects the new production node acording to the index into the &lt;code&gt;g_PrimaryStream&lt;/code&gt; array. The @ref xnProductionNodeTypeFromString() function returns an enum specifting a particular node type, e.g., XN_NODE_TYPE_DEPTH specifies a DepthGenerator node.

The user can invoke this functionality from the GUI user menu. The user can select a menu item to call this function.

The following statement calls the  @ref xn::Context::CreateAnyProductionTree() method.
</pre><h1><a class="anchor" id="device_cpp_createStream"></a>
createStream() - Creates a New Data Generatation Node</h1>
<pre class="fragment">This function creates a new stream by creating a new data generation node of a specified type calling the @ref xn::Context.CreateAnyProductionTree() method, as follows. 
@code 
    EnumerationErrors errors;
    XnStatus nRetVal = g_Context.CreateAnyProductionTree(type, NULL, generator, &amp;errors);
@endcode
This method enumerates for production nodes of a specific node type, and creates the first production node found of that type.
</pre><h1><a class="anchor" id="device_cpp_toggleStream"></a>
toggleStream() - Toggles between Starting and Stopping a Generator Node</h1>
<pre class="fragment">This function toggles between starting and stopping a generator node. The first two statements ensure that the specified generator is a valid node, and if not it calls createStream() (described above) to create a node of the required type.

In the following statement, the @ref xn::Generator::IsValid() method checks that the reference points to a real node instance, or to to NULL, where in the  latter case the function calls createStream() to create the generator node. 
@code 
    if (!generator.IsValid())
    {
        createStream(generator, type);
    }
@endcode

In the following code block, the @ref xn::Generator::IsGenerating() "IsGenerating()" method returns whether the node is currently in Generating state. @ref xn::Generator::StartGenerating() "StartGenerating()" enters the node into Generating state, and @ref xn::Generator::StopGenerating() "StopGenerating()" makes the node leave Generating state (it enters Non-Generating state).         

@code 
    if (generator.IsGenerating())
    {
        generator.StopGenerating();
    }
    else
    {
        generator.StartGenerating();
        ...
    }                       
@endcode

After the application has called StartGenerating() it can call an 'Update Data()' method, e.g., @ref xn::Generator::WaitAndUpdateData(), to make a new frame available for getting. The application can then get the data (for example, using a metadata GetData() method, or some other mechanism depending on the type of node).                      

This &lt;code&gt;toggleStream()&lt;/code&gt; function is used by a number of other functions to start and stop each of the generators in this application - see below.

Finally, this function then sets the boolean return parameter &lt;code&gt;bIsOn &lt;/code&gt;from the &lt;code&gt;IsGenerating()&lt;/code&gt; method. This parameter returns the updated 'Is Generating' state for all the 'Toggle Generating State' functions that follow below.
</pre><h1><a class="anchor" id="device_cpp_StartStopGen"></a>
Starting and Stopping each of the Generators</h1>
<pre class="fragment">The following group of functions start and stop each of the generators in this application. 
@code 
    void toggleDepthState(int nDummy)
    {
        toggleStream(g_Depth, XN_NODE_TYPE_DEPTH, &amp;g_bIsDepthOn);
    }

    void toggleImageState(int nDummy)
    {
        toggleStream(g_Image, XN_NODE_TYPE_IMAGE, &amp;g_bIsImageOn);
    }

    void toggleIRState(int nDummy)
    {
        toggleStream(g_IR, XN_NODE_TYPE_IR, &amp;g_bIsIROn);
    }

    void toggleAudioState(int nDummy)
    {
        toggleStream(g_Audio, XN_NODE_TYPE_AUDIO, &amp;g_bIsAudioOn);
    }       
@endcode    
</pre><h1><a class="anchor" id="device_cpp_ToggleMirror"></a>
Function: toggleMirror() - Toggles the Global Mirror</h1>
<pre class="fragment">This function can enable or disable the @ref xn::MirrorCapability "GlobalMirror" flag. For a detailed introduction to mirroring in OpenNI see @ref xn::MirrorCapability.

The following statement gets the current value of the Global Mirror using the @ref xn::Context::GetGlobalMirror() "GetGlobalMirror()" method and then inverses it using the @ref xn::Context::GetGlobalMirror() "GetGlobalMirror()" method.
@code 
    XnStatus nRetVal = g_Context.SetGlobalMirror(!g_Context.GetGlobalMirror())
@endcode

Use the GUI menu access to toggle the GlobalMirrior.
</pre><h1><a class="anchor" id="device_cpp_seekFrame"></a>
Function: seekFrame() - Seeks a Data Frame in a Recording</h1>
<pre class="fragment">This function seeks a data frame from the primary stream (generator node) in an OpenNI recording. 

The first thing this function does is to get the node name of the primary stream. if the primary stream is found to be NULL, this function then gets node name of any other valid node.

The following statement calls the @ref xn::Player::SeekToFrame() "SeekToFrame()" method to moves the player to a specific frame of a specific played node so that playing will continue from that frame onwards.
@code 
    nRetVal = g_Player.SeekToFrame(strNodeName, nDiff, XN_PLAYER_SEEK_CUR);
@endcode

In the call above, the &lt;code&gt;nDiff&lt;/code&gt; and &lt;code&gt;@ref xn::XN_PLAYER_SEEK_CUR&lt;/code&gt; parameters specify that the seek operation moves &lt;code&gt;nDiff&lt;/code&gt; frames from the current frame of the specified node. A positive value means to move forward, and a negative value means to move backwards. 

In the following statement, the call to the @ref xn::Player::TellFrame() "TellFrame()" method gets the absolute current frame number of a specific node played by a player, i.e., the number of frames passed since the beginning of the recording.

In the following statement, the call to the @ref xn::Player::GetNumFrames() "GetNumFrames()" method gets the number of frames of a specific node played by a player.
</pre><h1><a class="anchor" id="device_cpp_isgenon"></a>
Function: is 'Generator' On function</h1>
<pre class="fragment">The following group of functions all return whether the production node is on. For example:
@code 
    bool isDepthOn()
    {
        return (g_bIsDepthOn);
    }           
@endcode
</pre><h1><a class="anchor" id="device_cpp_setResolution"></a>
Function: setResolution() - Sets the Resolution of the Output Map</h1>
<pre class="fragment">This function sets the resolution component of the generator node's current map output mode. This map output mode includes the frame resolution, i.e., its X and Y dimensions, which are the number of elements in each of the X- and Y- axes) and also the frame rate. This is the map output mode that the generator node will use to generate its next data frame.

The resolution is provided y the &lt;code&gt;res&lt;/code&gt; parameter to this function call, which is an enum value of type @ref xn::XnResolution "XnResolution", e.g., @ref xn::XN_RES_QVGA "XN_RES_QVGA". 

The following code block calls the @ref xn::MapGenerator::GetMapOutputMode() "GetMapOutputMode()" method to get an @ref xn::XnMapOutputMode struct containing the generator node's current map output mode. The code then updates the mode's  resolution fields with new values, and then completes the operation by calling @ref xn::MapGenerator::SetMapOutputMode() "SetMapOutputMode()", passing the @ref xn::XnMapOutputMode struct as a parameter, to update the node's map output mode.
@code 
    XnMapOutputMode Mode;
    pGenerator-&gt;GetMapOutputMode(Mode);
    Mode.nXRes = Resolution((XnResolution)res).GetXResolution();
    Mode.nYRes = Resolution((XnResolution)res).GetYResolution();
    XnStatus nRetVal = pGenerator-&gt;SetMapOutputMode(Mode);
@endcode

See also the setFPS() function (the next function, below) for setting the frame rate.

In the above, the 'Resolution' term is an OpenNI utility class for easy handling of resolution information. It creates a @ref xn::Resolution "Resolution" object from an enum value of type @ref xn::XnResolution "XnResolution", from which you can then get the X and Y dimensions if the frame.
</pre><h1><a class="anchor" id="device_cpp_setfps"></a>
Function: setFPS() - Selects a Resolution for the Output Map</h1>
<pre class="fragment">This function sets the frame rate component of the generator node's current map output mode. 

This function works in a similar way to the &lt;code&gt;setResolution()&lt;/code&gt; function above. 

The following code block calls the @ref xn::MapGenerator::GetMapOutputMode() "GetMapOutputMode()" method to get an @ref xn::XnMapOutputMode struct containing the generator node's current map output mode. The code then updates the mode's  frmae rate field, &lt;code&gt;nFPS&lt;/code&gt;, with a new value, and then completes the operation by calling @ref xn::MapGenerator::SetMapOutputMode() "SetMapOutputMode()", passing the @ref xn::XnMapOutputMode struct as a parameter, to update the node's map output mode.
@code 
    XnMapOutputMode Mode;
    pGenerator-&gt;GetMapOutputMode(Mode);
    Mode.nFPS = fps;
    XnStatus nRetVal = pGenerator-&gt;SetMapOutputMode(Mode);
@endcode    
</pre><h1><a class="anchor" id="device_cpp_grp_setResolutionFps"></a>
'setResolution/Fps()' - Group of Functions for Setting Resolutions and Frame Rates</h1>
<pre class="fragment">The next functions defined in this file are a group of functions for setting  resolutions and frame rates for all generators in this sample application. All use the methods just defined above, @ref device_cpp_setResolution "setResolution()" and @ref device_cpp_setfps "setFPS()". The code below shows  some examples. 
@code 
    void setDepthResolution(int res)
    {
        setResolution(getDepthGenerator(), res);
    }
    ...
    ...
    void setImageFPS(int fps)
    {
        setFPS(getImageGenerator(), fps);
    }
@endcode

The 'get' functions used in the above are defined later in this file.

All these 'set resolution/fps' functions are invoked by the user clicking the GUI menu items to make these settings. 
</pre><h1><a class="anchor" id="device_cpp_setStreamCropping"></a>
Function: setStreamCropping() - Crops the Map Area of the Generator Output</h1>
<pre class="fragment">This function crops the map area of the generator output.

&lt;b&gt;Usage: &lt;/b&gt; For user area selections where the user can use the mouse to select just a part of the full map area for applying OpenNI or other graphic operations.

&lt;b&gt;Parameters: &lt;/b&gt; 

&lt;code&gt;pGenerator&lt;/code&gt; - generator node for which to set the cropping area.

&lt;code&gt;pCropping&lt;/code&gt; -  @ref xn::XnCropping struct containing the cropping details.

The following statement checks that the generator node exists.
@code 
    if (pGenerator == NULL)
    {
        displayMessage("Stream does not exist!");
        return;
    }           
@endcode

The code first checks that the capability exists using the @ref xn::Generator::IsCapabilitySupported "IsCapabilitySupported()" method.

The code then gets the crop capability using the @ref xn::MapGenerator::GetCroppingCap()  "GetCroppingCap()" method, and through it calls  the @ref xn::CroppingCapability::SetCropping() method.
</pre><h1><a class="anchor" id="device_cpp_setPlaybackSpeed"></a>
Function: setPlaybackSpeed() - Sets the  playback speed</h1>
<pre class="fragment">&lt;b&gt;Group:&lt;/b&gt;  Recording and Playback 
{If I want to use this format I will have to go back and make it consistent - ie at least for this sample NiViewer.}

&lt;b&gt;Parameter:&lt;/b&gt;  ratioDiff - Ratio of recording rate 

This function sets the playback speed of an OpenNI recording as a ratio of the rate that the recording was made at. This OpenNI recording is a recording of all the actual map data that was generated during the time that recording was enabled. This is not the  same as a production graph stired in an OpenNI XML script file: a script file stores only the structure of the production graph but not the data that the production graph has or will generate.
@code 

    XnDouble dNewSpeed = g_Player.GetPlaybackSpeed() * pow(2.0, (XnDouble)ratioDiff);
    XnStatus nRetVal = g_Player.SetPlaybackSpeed(dNewSpeed);
@endcode
</pre><h1><a class="anchor" id="device_cpp_getPlaybackSpeed"></a>
Function: getPlaybackSpeed() - Gets the  playback speed</h1>
<pre class="fragment">&lt;b&gt;Group:&lt;/b&gt;  Recording and Playback 

This function calls the @ref xn::Player::GetPlaybackSpeed() to get current playback speed. If the player is not valid it returns the "identity' ratio, 1. 
</pre><h1><a class="anchor" id="device_cpp_grp_getobject"></a>
Function: setFPS() - Group of Functions for Setting Resolutions and Frame Rates</h1>
<pre class="fragment">Next is a group of functions for getting pointers to certain OpenNI objects: to production nodes, generators, and metadata objects. The code below shows some examples. 
These  functions achieve a way of simply indicating as a boolean flag whether the nodes are actual &lt;i&gt;created&lt;/i&gt; nodes, i.e., whether they have been initialized and made operational in the @ref prod_graph "production graph", or   they are still in the 'pre-creation'  state, i.e., they have been constructed as C++ objects but have not yet undergone creation.
@code 
    Device* getDevice()
    {
        return g_Device.IsValid() ? &amp;g_Device : NULL;
    }
    DepthGenerator* getDepthGenerator()
    {
        return g_Depth.IsValid() ? &amp;g_Depth : NULL;
    }
    ...
    ...
    const AudioMetaData* getAudioMetaData()
    {
        return g_Audio.IsValid() ? &amp;g_AudioMD : NULL;
    }
@endcode</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 17 2014 17:19:11 for OpenNI 1.5.4 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
