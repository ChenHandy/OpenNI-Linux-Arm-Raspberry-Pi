<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.4: NiRecordRaw.cpp - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NiRecordRaw.cpp - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>NiRecordRaw.cpp</li>
</ul>
<p>This section describes an OpenNI sample program for recording raw data, and then playing it back. Recording raw data may be useful for middleware developers who produce a custom type of data that isn't defined by OpenNI. In addition, recording raw data may also be useful for middleware developers who save additional debugging information in the ONI file. This additional data may be used in conjunction with the standard OpenNI data types such as depth output data stored in the file. In this case, each frame of debugging information will match a depth frame.</p>
<p>In this sample, the raw data is artificial data that the application itself synthesizes.</p>
<h1><a class="anchor" id="recraw__sample_xml_path"></a>
Declaration of File Paths</h1>
<pre class="fragment">In the following definitions, SAMPLE_XML_PATH is for the path to an OpenNI XML script input file for building a stored production graph. The &lt;i&gt;production graph&lt;/i&gt; is a network of &lt;i&gt;production nodes&lt;/i&gt; and is the principal OpenNI object model. See @ref prod_graph for more about production graph. RECORDING_FILE_NAME is the OpenNI output file to store the recording.
@code 
    #define SAMPLE_XML_PATH "../../../../Data/SamplesConfig.xml"
    #define RECORDING_FILE_NAME "recordingWithRaw.oni"
@endcode            
</pre><h1><a class="anchor" id="bkrec_macros"></a>
Macro Declarations</h1>
<pre class="fragment">At the top of the program are two macro utility declarations, both of which call OpenNI methods. They are described below. However, for the sake of conciseness, the rest of this documentation skips calls to these macros.

The CHECK_RC_ERR() macro checks whether the most recent OpenNI operation for creating a production graph actually created a production graph or not. If no production graph was created (indicated by the &lt;code&gt;XN_STATUS_NO_NODE_PRESENT&lt;/code&gt; return code), the @ref xn::xnGetStatusString "xnGetStatusString()" method converts an error list to a  error string for printing. Either way, this macro then calls the &lt;code&gt;CHECK_RC()&lt;/code&gt; macro described above.
@code 
    #define CHECK_RC_ERR(rc, what, error) \
      ...           
@endcode    
</pre><h1><a class="anchor" id="recraw_mainprg_dcl_blk"></a>
Main Program - Declaration Block</h1>
<pre class="fragment">The declaration block at the top of the main program declares an OpenNI status flag for collecting return values from method calls.
@code 
    XnStatus nRetVal = XN_STATUS_OK;
@endcode
</pre><h1><a class="anchor" id="recraw_mainprg"></a>
Main Program</h1>
<pre class="fragment">@subsection recraw_record Recording Data

    In the following, the @ref xn::xnLogInitFromXmlFile() function initializes the log from an XML file. 
    @code 
        nRetVal = xnLogInitFromXmlFile(SAMPLE_XML_PATH);
    @endcode

    The following initalizes the @ref xn::Context object. This is a workspace where the application builds an OpenNI production graph. The &lt;i&gt;production graph&lt;/i&gt; is a network of &lt;i&gt;production nodes&lt;/i&gt; and is the principal OpenNI object structure.
    @code 
        Context context;
        nRetVal = context.Init();
    @endcode

    The following statement initializes a Recorder object. This object records to a specified destination medium the frames of data from each node that was added to the Recorder node. 
    @code 
        nRetVal = recorder.Create(context);
    @endcode

    The following call specifies to where the recorder must send its recording. 

    @note Disk files are the only medium that this installation currently supports.

    @code 
        nRetVal = recorder.SetDestination(XN_RECORD_MEDIUM_FILE, RECORDING_FILE_NAME);
    @endcode        

    The following code creates a mock node. This is to simulate an actual node when recording or playing data from a recording. A mock node does not contain any logic for generating data. Instead, it allows an outside component &amp;ndash; such as an application or a real node &amp;ndash; to feed it configuration changes and data. 
    @code 
        MockRawGenerator rawGenerator;
        nRetVal = rawGenerator.Create(context, "MockRaw");
    @endcode        

    The following statements set properties of the @ref xn::MockRawGenerator "rawGenerator" node. It creates a string property named Type and assigns it the value "ReverseT", creates an integer property named X and assigns it the value 5.  This depends on the middleware developer that is using this feature. It could be any parameter that the middleware code might later need for debugging purposes or for custom data types.
    @code 
        nRetVal = rawGenerator.SetStringProperty("Type", "ReverseT");
        nRetVal = rawGenerator.SetIntProperty("X", 5);
    @endcode

    The following statement adds the node to the recording setup, and starts recording it.
    @code 
        nRetVal = recorder.AddNodeToRecording(rawGenerator);
    @endcode

    The following example shows that properties can also be set after the node has been added to the recording. 
    @code 
        nRetVal = rawGenerator.SetIntProperty("Y", 8);
    @endcode

    The following main application loop sets artificial data in the rawGenerator node. The parameters to the SetData() call, in order, are nFrameID and nTimestamp, both generated from the loop counter - abd then the nDataSize and a pointer to the data buffer.         
    @code 
        XnChar buff[20];
        for (XnUInt32 i = 1; i &lt;= 10; i++)
        {
            for (XnUInt32 j = 0; j &lt; 20; j++)
            {
                buff[j] = i;
            }
            nRetVal = rawGenerator.SetData(1000 * i, i, sizeof(buff), buff);nRetVal = recorder.Record();
    @endcode

    In the above, the @ref xn::Recorder::Record() "Record()" method records one frame of data from each node added to the recorder. To record continually, the recorder node must be called repeatedly for each frame.

    On completion of the loop, the following code removes the node from the Recorder object and so stops recording the node output. The code then releases the @ref xn::Recorder "Recorder" and  @ref xn::MockRawGenerator "MockRawGenerator" nodes. Releasing the nodes unreferences them, decreasing their reference counts by 1. If a node's reference count reaches zero, it will be destroyed. 
    @code 
        nRetVal = recorder.RemoveNodeFromRecording(rawGenerator);
           ...
        recorder.Release();
           ...
        rawGenerator.Release();
    @endcode

    This completes the recording example. All recorded data has been recorded in the file whose name is given in RECORDING_FILE_NAME.

@subsection recraw_play Plays Back Recorded Data

    The application now builds a production graph to play back the data recorded above 

    The following statement gets a handle to an existing production node instance using that instance name. It is already known that there exists a node with the instance name "MockRaw".  
    @code 
        nRetVal = context.GetProductionNodeByName("MockRaw", rawGenerator);
    @endcode

    The following code replays a recorded file of a session of OpenNI data generation exactly as it was recorded. the @ref xn::Player node is for playing a saved recording of an OpenNI data generation session. The RECORDING_FILE_NAME string contains the file name, as above. 
    @code 
        Player player;
        nRetVal = context.OpenFileRecording(RECORDING_FILE_NAME, player);
    @endcode            

    The following statement specifies whether the player will automatically rewind to the beginning of the recording after reaching the end of the recording.
    @code 
        nRetVal = player.SetRepeat(FALSE);
    @endcode

    @code 
        nRetVal = context.GetProductionNodeByName("MockRaw", rawGenerator);
    @endcode

    The following program loop waits for available data from any generator node and prints it out. The @ref xn::Context::WaitAnyUpdateAll() "WaitAnyUpdateAll()" method updates all generator nodes in the context that have new data available, first waiting for any of the nodes to have new data available. The application can then get the data (for example, using a metadata &lt;code&gt;GetData()&lt;/code&gt; method). This method has a timeout.         
    @code 
        while ((nRetVal = context.WaitAnyUpdateAll()) != XN_STATUS_EOF)
        {
            CHECK_RC(nRetVal, "Read data from file");
            pData = (const XnChar*)rawGenerator.GetData();
            nSize = rawGenerator.GetDataSize();
            for (XnUInt32 i = 0; i &lt; nSize; i++)
            {
                printf("%d ", pData[i]);
            }
            printf("\n");
        }
    @endcode

    On completion of the loop, the following code removes the node from the Player  object and and so stops playing the recording. All other objects are also released. See ealier for a more detailed description of Release().
    @code 
        player.Release();
        rawGenerator.Release();
        recorder.Release();
        context.Release();
    @endcode</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 17 2014 17:19:10 for OpenNI 1.5.4 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
