<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.4: NiRecordSynthetic.cpp - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NiRecordSynthetic.cpp - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre class="fragment">&lt;b&gt;Source file:&lt;/b&gt; Click the following link to view the source code file:
    - NiRecordSynthetic.cpp

This section describes an OpenNI sample program for generating and recording synthetic data.

The program opens a recording, performs a transformation on the data from the recording, and then re-records the transformed data.

The documentation describes the sample program's code from the top of the program file(s) to bottom.

Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.    

@section rec_syn_xform_depthmd transformDepthMD() function

    The following function provides the code for performing a transformation on the image data generated by the OpenNI @ref prod_graph "nodes". The function is described further below feature by feature. 
    @code 
        void transformDepthMD(DepthMetaData&amp; depthMD)
        {
            DepthMap&amp; depthMap = depthMD.WritableDepthMap();
            for (XnUInt32 y = 0; y &lt; depthMap.YRes(); y++)
            {
                for (XnUInt32 x = 0; x &lt; depthMap.XRes(); x++)
                {
                    //Punch vertical cut lines in the depth image
                    if ((x % 2) == 0)
                    {
                        depthMap(x, y) = 0;
                    }
                }
            }
        }       
    @endcode    

    In the above, the @ref xn::DepthMetaData "DepthMetaData" object provides a @ref glos_frame_object "frame object" for the @ref xn::DepthGenerator node. The @ref glos_frame_object "frame object" of a @ref dict_gen_node "generator node" contains a snapshot of generated data frame and all its associated properties. This data frame and its properties are accessible through the node's metadata object.  

    &lt;code&gt;DepthMap&lt;/code&gt; is a Map Wrapper class. The Map Wrapper classes are light wrappers for @ref glos_frame_object maps.

    The @ref xn::DepthMetaData::WritableDepthMap() "WritableDepthMap()" method gets a light object to wrap the writable depth map. So this initializes the DepthMap map wrapper class.      
    @code 
        DepthMap&amp; depthMap = depthMD.WritableDepthMap();
    @endcode

    The following double loop provides the x and y indexes to access each pixel in the &lt;code&gt;DepthMap&lt;/code&gt;. The @ref xn::DepthMap::XRes "XRes()" and @ref xn::DepthMap::YRes "YRes()" methods return the two dimensions of the data frame, width and height, respectively. 
    @code 
        for (XnUInt32 y = 0; y &lt; depthMap.YRes(); y++)
        {
            for (XnUInt32 x = 0; x &lt; depthMap.XRes(); x++)
            {
             ...
            } 
        }
    @endcode            

    Here is the code that performs the data transformation. It punches vertical 'cut' lines in the depth image.
    @code 
        if ((x % 2) == 0)
        {
            depthMap(x, y) = 0;
        }       
    @endcode    

@section rec_syn_mainprg main() &amp;ndash; Main Program

    @subsection rec_syn_mainprg_dcl_blk Main Program Declaration Block      

    @subsection rec_syn_record Initializing the Log from an XML file

        In the following, the @ref xn::xnLogInitFromXmlFile() method function initializes the log from an XML file. It initializes only the log; not the context or production graph.            
        @code 
            nRetVal = nRetVal = xnLogInitFromXmlFile(SAMPLE_XML_PATH);
            if (nRetVal != XN_STATUS_OK)
            {
                printf("Log couldn't be opened: %s. Running without log", xnGetStatusString(nRetVal));
            }
        @endcode

    @subsection rec_syn_getparams Creating and Setting up the Nodes

        The following initializes the @ref xn::Context object. This is where the application builds an OpenNI production graph. The &lt;i&gt;production graph&lt;/i&gt; is a network of &lt;i&gt;production nodes&lt;/i&gt; and is the principal OpenNI object structure.
        @code 
            Context context;
            nRetVal = context.Init();
        @endcode

        The @ref xn::Context::OpenFileRecording() "OpenFileRecording()" method replays a recorded file of a session of OpenNI data generation exactly as it was recorded. This includes recreating the whole @ref prod_graph "production graph", with all its nodes, that was built to run the original data generation session. This method performs this replaying by also creating a 'mock node' for each node in the file, and populates it with the recorded configuration. For an example of a mock node, see @ref xn::MockDepthGenerator.
        @code 
            Player player;
            nRetVal = context.OpenFileRecording(strInputFile, player);
        @endcode    

        In the following code, the @ref xn::Context::FindExistingNode() "FindExistingNode()" method call gets a reference to a production node in the production graph. This sample program passes the &lt;code&gt;depth&lt;/code&gt; parameter to get a reference to a @ref xn::DepthGenerator "DepthGenerator node" so that it can work with it. A @ref xn::DepthGenerator node generates a depth map. Each map pixel value represents a distance from the sensor.
        @code 
        DepthGenerator depth;
        nRetVal = context.FindExistingNode(XN_NODE_TYPE_DEPTH, depth);
        @endcode
</pre><p>Create mock node based on depth node from recording The following declares a mock node. This is to simulate an actual node when recording or playing data from a recording. A mock node does not contain any logic for generating data. Instead, it allows an outside component (such as an application or a real node implementation) to feed it configuration changes and data. </p>
<div class="fragment"><div class="line">MockDepthGenerator mockDepth;</div>
</div><!-- fragment --><p>In the following statement, the <a class="el" href="classxn_1_1_mock_depth_generator.html">xn::MockDepthGenerator</a> node::CreateBasedOn() "CreateBasedOn()" method <em>creates</em> a "mock" <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node based on the type and properties of the base node, in this case the <code>depth</code> node. This node does not represent an actual node, but only keeps a state and implements an interface above it. Mock nodes are specifically used for simulating nodes for playing recordings, or for use in tests. </p>
<div class="fragment"><div class="line">nRetVal = mockDepth.CreateBasedOn(depth);</div>
</div><!-- fragment --><p>In the following, the call to <a class="el" href="classxn_1_1_recorder.html#a4d544321e6bcad40d68db50353a0d6ee">Create()</a> initalizes a Recorder object. This object records to a specified destination medium the frames of data from each node that was added to it. </p>
<div class="fragment"><div class="line">Recorder recorder;</div>
<div class="line">nRetVal = recorder.Create(context);</div>
</div><!-- fragment --><p>In the following statement, the call to <a class="el" href="classxn_1_1_recorder.html#a1e84f796966c9808b2a26db0d5dfe621">SetDestination()</a> specifies to where the recorder must send its recording. This is a disk file of ONI type. </p>
<div class="fragment"><div class="line">nRetVal = recorder.SetDestination(<a class="code" href="group__recorder.html#gga3a9ee4c35a7384ba06a4d22f976f8e8aab2fd201e9160a675b83ca2a3e4d36a0c">XN_RECORD_MEDIUM_FILE</a>, strOutputFile);</div>
</div><!-- fragment --><p>The following statement adds the node to the recording, and starts recording it. </p>
<div class="fragment"><div class="line">nRetVal = recorder.AddNodeToRecording(mockDepth);</div>
</div><!-- fragment --><p>The following statement specifies that the player will not automatically rewind to the beginning of the recording after reaching the end of the recording (the default behavior is to rewind). </p>
<div class="fragment"><div class="line">nRetVal = player.SetRepeat(<a class="code" href="_xn_platform_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);</div>
</div><!-- fragment --><p>The next code block gets the number of frames of a specific node played. In the case of this sample program this is just a statistic to print later on the console. </p>
<div class="fragment"><div class="line">XnUInt32 nNumFrames = 0;</div>
<div class="line">nRetVal = player.GetNumFrames(depth.GetName(), nNumFrames);</div>
</div><!-- fragment --><p>The following declares a metadata object for the DepthGenerator node. The metadata object is described above in the <a class="el" href="/home/pi/project/OpenNI-unstable/Source/DoxyGen/Text/SampleProgs_NiRecordSynthetic.txt.html#rec_syn_xform_depthmd">transformDepthMD() function</a> transformDepthMD() function. </p>
<div class="fragment"><div class="line">DepthMetaData depthMD;</div>
</div><!-- fragment --><pre class="fragment">Following is the main program loop. It waits for available data from the generator and prints it out. The call to the n::Generator::WaitAndUpdateData() "WaitAndUpdateData()" method updates the node's application buffer to the latest available data, first waiting for the  node to have new data available. Since this method is being fed from a recording, the end of the recording is indicated by returning the XN_STATUS_EOF value. 

Note that the @ref xn::Generator::WaitAndUpdateData() "WaitAndUpdateData()" method has to be called for each and every iteration to refresh the node's data.
@code 
    while ((nRetVal = depth.WaitAndUpdateData()) != XN_STATUS_EOF)
    {
        ...
    }
@endcode            

The statements of body of the main loop are presented and explained, in the following.

The following statement gets the DepthGenerator node's @ref glos_frame_object "frame object" (the @ref xn::DepthMetaData frame object). The metadata object is described above in the @ref rec_syn_xform_depthmd transformDepthMD() function.
@code 
    depth.GetMetaData(depthMD);
@endcode

Enable the depth map to be modified. In the following statement, the call to the @ref xn::OutputMetaData::MakeDataWritable() "MakeDataWritable()" allocates a buffer and copies current data to it, so that the data can be edited. 
@code 
    nRetVal = depthMD.MakeDataWritable();
@endcode    

The following statement makes a call to the transformDepthMD(), already described above in @ref rec_syn_xform_depthmd. This call transforms the data.
@code 
    transformDepthMD(depthMD);
@endcode    

The following statement passes the transformed data to the @ref xn::MockDepthGenerator object. The call to the @ref xn::MockDepthGenerator::SetData() "SetData()" method sets the data of the mock node from a metadata object.
@code 
    nRetVal = mockDepth.SetData(depthMD);
@endcode    

The following statement records one frame of data from each node that was added to the recorder by the @ref xn::Recorder::AddNodeToRecording() "AddNodeToRecording()" method.  To record continually, the Recorder node must be called repeatedly for each frame.
@code 
    nRetVal = Recorder.Record();
@endcode    

Finally, this sample program prints status information. In the statement below, the @ref xn::OutputMetaData::FrameID() "FrameID()" method gets the frame ID of @ref glos_frame_object "frame object". Frame IDs are a sequential unique number. 
@code 
    printf("Recorded: frame %u out of %u\r", depthMD.FrameID(), nNumFrames);
@endcode    </pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 17 2014 17:19:10 for OpenNI 1.5.4 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
