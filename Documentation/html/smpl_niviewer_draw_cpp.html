<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenNI 1.5.4: Draw.cpp file</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li><li class="navelem"><a class="el" href="smpl_niviewer.html">NiViewer - sample program</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Draw.cpp file </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre class="fragment">&lt;b&gt;Source files:&lt;/b&gt; Click the following link to view the source code file:
    - Draw.cpp
</pre><p>This file contains the code for displaying the frames from the OpenNI generator nodes.</p>
<h1><a class="anchor" id="draw_cpp_glb_decls"></a>
Global Type Declarations for Capture.cpp</h1>
<pre class="fragment">There are no OpenNI specific golbal declarations. 
</pre><h1><a class="anchor" id="draw_cpp_fns_getpoweroftwo_to_setErrorState"></a>
Functions GetPowerOfTwo() to setErrorState()</h1>
<pre class="fragment">There are no OpenNI specific operations in these functions. 
</pre><h1><a class="anchor" id="draw_cpp_drawcropstream"></a>
Function: drawCropStream() - Draws a Cropped Map from the Generator nodes</h1>
<pre class="fragment">This function draws a cropped map from each of the generator nodes.

&lt;b&gt;Parameters:&lt;/b&gt;

    &lt;code&gt;pGenerator&lt;/code&gt;: Specifies one of the three map generator nodes: DepthGenerator, ImageGenerator node, or ImageGenerator node.

First of all this function calls @ref xn::Generator::IsCapabilitySupported() to check whether this OpenNI installation supports a cropping capability.
@code 
    if (!pGenerator-&gt;IsCapabilitySupported(XN_CAPABILITY_CROPPING))
    {
        return;
    }
@endcode

This function calls @ref xn::MapGenerator::GetMapOutputMode() to get the Generator node's map output mode, which contains the node's current frame dimensions. the map output mode is obtaiend as an @ref xn::XnMapOutputMode "XnMapOutputMode" structure. The frame dimensions are needed for drawing the map on the graphic display.
@code 
    XnMapOutputMode Mode;
    pGenerator-&gt;GetMapOutputMode(Mode);     
@endcode    

An OpenNI @ref xn::XnCropping structure is used for containing the cropping location. Its fields are shown in the code block below.
@code 
    XnCropping cropping;
    cropping.bEnabled = TRUE;
    cropping.nXOffset = cropRect.uLeft;
    cropping.nYOffset = cropRect.uBottom;
    cropping.nXSize = cropRect.uRight - cropRect.uLeft;
    cropping.nYSize = cropRect.uTop - cropRect.uBottom;

    if ((cropping.nXOffset % dividedBy) != 0)
        cropping.nXOffset -= (cropping.nXOffset % dividedBy);
    if ((cropping.nXSize % dividedBy) != 0)
        cropping.nXSize += dividedBy - (cropping.nXSize
@endcode    

Finally, the function assigns the cropping setting to the Generator node. To do this it calls 
@ref device_cpp_setStreamCropping "&lt;code&gt;setStreamCropping()&lt;/code&gt;", which si defined in the &lt;code&gt;Device.cpp&lt;/code&gt; file of this sample program.
</pre><h1><a class="anchor" id="draw_cpp_drawSelectionChanged"></a>
Function: drawSelectionChanged() - Callback invoked when Draw Selection has Changed</h1>
<pre class="fragment">This callback is invoked when the draw selection has been changed.

This callback calls the @ref draw_cpp_drawcropstream function defined above for each valid Generator node. For example:
@code 
    if (getDepthGenerator() != NULL &amp;&amp; g_DrawConfig.Streams.Depth.Coloring != DEPTH_OFF)
    {
        drawCropStream(getDepthGenerator(), g_DrawConfig.DepthLocation, selection, 2);
    }
@endcode
</pre><h1><a class="anchor" id="draw_cpp_calculateHistogram"></a>
Function: calculateHistogram() - Calculates Depth Histogram</h1>
<pre class="fragment">This function uses the depth values to build an accumulative histogram of frequency of occurrence of each depth value. The *pDepth pointer accesses each value in the depth buffer. It then uses the value as an index into the g_pDepthHist histogram array.
</pre><h1><a class="anchor" id="draw_cpp_YUV422ToRGB888"></a>
Function: YUV422ToRGB888() - Converts Formats</h1>
<pre class="fragment">There are no OpenNI operations in this function.
@code 
    // --------------------------------
    // Drawing
    // --------------------------------
    #if (XN_PLATFORM == XN_PLATFORM_WIN32)

    void YUV422ToRGB888(const XnUInt8* pYUVImage, XnUInt8* pRGBAImage, XnUInt32 nYUVSize, XnUInt32 nRGBSize)
    {       
        ...
        ...

@endcode
</pre><h1><a class="anchor" id="draw_cpp_drawClosedStream"></a>
Function: drawClosedStream() - Converts Formats</h1>
<pre class="fragment">There are no OpenNI operations in this function.
</pre><h1><a class="anchor" id="draw_cpp_drawColorImage"></a>
Function: drawColorImage() - Draws the Color Image Map</h1>
<pre class="fragment">This function draws the color image map for either the ImageGenerator map or the IRGenerator node.

This function gets saved @ref glos_frame_object "frame objects", assigning them to &lt;code&gt;pImageMD&lt;/code&gt; and draws them to the graphic display. The frame object is a snapshot of the generated data, saved as a metadata object, at a certain point in time. The @ref xn::OutputMetaData::Data() method gets a pointer to the data frame of the frame object saved in the metadata. 
@code 
    if (isImageOn())
    {
        pImageMD = getImageMetaData();
        pImage = getImageMetaData()-&gt;Data();
    }
    else if (isIROn())
    {
        pImageMD = getIRMetaData();
        pImage = (const XnUInt8*)getIRMetaData()-&gt;Data();
    }
    else
        return;     
@endcode

The code block above gets a pointer to the data frame of the frame object saved in the metadata. The frame object is a snapshot of the generated data at a certain point in time.

The main draw operations are controlled by the following for-loop.
@code 
    for (XnUInt16 nY = pImageMD-&gt;YOffset(); nY &lt; pImageMD-&gt;YRes() + pImageMD-&gt;YOffset(); nY++)
    {
        XnUInt8* pTexture = TextureMapGetLine(&amp;g_texImage, nY) + pImageMD-&gt;XOffset()*4;
        ...
        ...
@endcode

The above loop provides the y indexes to access each pixel in the &lt;code&gt;DepthMap&lt;/code&gt;. The @ref xn::DepthMap::YRes "YRes()" method returns the Y dimension -- height -- of the data frame. 

The following code uses the FullXRes() to calculate the scaling factor between the depth map and the GL window. FullXRes() gets the full frame resolution, i.e., the entire field-of-view, ignoring cropping of the FOV in the scene.
@code 
    if (pDepthMetaData != NULL)
    {
        XnDouble dRealX = (nX + pImageMD-&gt;XOffset()) / (XnDouble)pImageMD-&gt;FullXRes();
        XnDouble dRealY = nY / (XnDouble)pImageMD-&gt;FullYRes();

        XnUInt32 nDepthX = dRealX * pDepthMetaData-&gt;FullXRes() - pDepthMetaData-&gt;XOffset();
        XnUInt32 nDepthY = dRealY * pDepthMetaData-&gt;FullYRes() - pDepthMetaData-&gt;YOffset();

        if (nDepthX &gt;= pDepthMetaData-&gt;XRes() || nDepthY &gt;= pDepthMetaData-&gt;YRes())
        {
            nDepthIndex = -1;
        }
        else
        {
            nDepthIndex = nDepthY*pDepthMetaData-&gt;XRes() + nDepthX;
        }
    }       
@endcode
</pre><h1><a class="anchor" id="draw_cpp_drawDepth"></a>
Function: drawDepth() - Draws the Depth Map</h1>
<pre class="fragment">This function is implemented in a way similar to that of the draw_cpp_drawColorImage function above.

Of note is the &lt;&gt;&lt;code&gt;++pDepth&lt;/code&gt; term in the code block below.
@code 
    for (XnUInt16 nY = pDepthMD-&gt;YOffset(); nY &lt; pDepthMD-&gt;YRes() + pDepthMD-&gt;YOffset(); nY++)
    {
        XnUInt8* pTexture = TextureMapGetLine(&amp;g_texDepth, nY) + pDepthMD-&gt;XOffset()*4;
        for (XnUInt16 nX = 0; nX &lt; pDepthMD-&gt;XRes(); nX++, pDepth++, pTexture+=4)
@endcode

&lt;b&gt;&lt;code&gt;++pDepth&lt;/code&gt;:&lt;/b&gt;  This pointer is incremented by 1 for each inner loop. So it steps through all the pixels in the Depth map. Thus the program can get each pixel's depth value.</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 17 2014 17:19:11 for OpenNI 1.5.4 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
